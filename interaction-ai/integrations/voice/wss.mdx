---
title: "Integration Guide for Websocket Connection"
description: "This documentation provides a comprehensive integration guide for connecting third-party telephony platforms (like Exotel, Twilio, Knowlarity) with Formi's AI-powered voice interaction system via WebSockets."
---

## **Overview**

Formi enables intelligent AI-powered voice interactions over websocket through real-time audio streaming. This guide is for any client or partner integrating **third-party telephony services** (e.g., **Exotel,** Twilio, Knowlarity, etc.) with Formi using **WebSockets**.

This documentation provides a comprehensive guideline on how to:

1. Set up call metadata exchange with Formi
2. Initiate or reuse a session on Formi’s platform
3. Establish a direct WebSocket connection with Formi
4. Stream and receive audio in real-time

![Screenshot2025 06 25at3 42 06PM Pn](/images/Screenshot2025-06-25at3.42.06PM.png)

---

## **Understand Formi's Call Architecture**

When a voice interaction is initiated or answered, your telephony provider should trigger a WebSocket stream to Formi's URL that includes essential call metadata. This metadata helps Formi:

1. Identify the interaction, session and any previous interaction context.
2. Associate the call with the correct agent.
3. Attach the [<u>correct AI workflow</u>](http://config.formi.co.in) or business logic to the session

### Methods to set Interaction

<CardGroup cols={2}>
  <Card title="Inbound Interactions" icon="sparkles">
    1. Use Formi's **Create Session API** to explicitly initiate the session
  </Card>
  <Card title="Outbound Interactions" icon="sparkles">
    1. Setup and Source & Queue Calls on our System
  </Card>
</CardGroup>

## **Construct the WebSocket URL**

Formi expects WebSocket connections in the following format:

```python
websocket_url = f"wss://api-2.formi.co.in/communication/{call_type}/{agent_id}/{outlet_id}/{CallFrom}/{CallSid}/{session_id}/{interaction_id}"
```

---

**Parameters**

| **Parameter**  | **Description**                                 |
| :------------- | :---------------------------------------------- |
| call_type      | inbound, outbound, confirmation, or missed      |
| agent_id       | The Formi agent ID                              |
| outlet_id      | The outlet or business unit ID                  |
| CallFrom       | Customer contact ID (phone or email)            |
| CallSid        | Unique call identifier generated by your system |
| session_id     | Returned by Formi Create Session API            |
| interaction_id | Returned by Formi Create Session API            |

```python create.py [expandable]
import json
async def test_exotel_live_formi(
    call_type:Literal["confirmation","missed","inbound","outbound"],
    agent_id: int,
    outlet_id: int,
    CallFrom: str,
    CallSid: str,
    CallTo: str,
    Direction: str,
    Created: str,
    DialWhomNumber: str,
    HangupLatencyStartTimeExocc: str | None,
    HangupLatencyStartTime: str | None,
    From: str,
    To: str,
    CurrentTime: str,
    CustomField:str | None = None
):

    if CustomField is not None:
        custom_field_converted = json.loads(CustomField)
        session_id = str(custom_field_converted.get("session_id", ""))
        interaction_id = str(custom_field_converted.get("interaction_id", ""))
    else:
        # new session creation here
        try:
            response = await create_session_details(outlet_id=outlet_id, customer_phone_number=CallFrom, modality="call", direction="inbound")
            session_id = response.session_id
            interaction_id = response.interaction_id
        except Exception as e:
            session_id = ""
            interaction_id = ""

    if session_id == "" or interaction_id == "":
        logging.info("Session ID or Interaction ID is not present in the custom field")

    websocket_url = {settings.SELF_WSS_URL}/communication/{call_type}/{agent_id}/{outlet_id}/{CallFrom}/{CallSid}/{session_id}/{interaction_id}"
```

## **Establish the WebSocket Connection**

Once the WebSocket URL is constructed, the telephony system must initiate a WebSocket connection and begin sending a predefined sequence of structured messages to Formi.

### **WebSocket Message Types**

Below is a list of all supported message types, along with parameters and examples

**From Formi**

<AccordionGroup>
  <Accordion title="connected">
    <Info>
      Sent automatically when the WebSocket connection is successfully established
    </Info>
    ```json
    {
      "event": "connected"
    }
    ```

    | **<u>Field</u>** | **<u>Description</u>**                                |
    | :--------------- | :---------------------------------------------------- |
    | **event**        | Indicates connection status. Always set to connected. |
    |                  |                                                       |
  </Accordion>
  <Accordion title="start">
    <Info>
      Sent once after connected, contains stream and call metadata.
    </Info>
    ```json
    {
      "event": "start",
      "sequence_number": 1,
      "stream_sid": "stream-xyz",
      "start": {
        "stream_sid": "stream-xyz",
        "call_sid": "call-abc",
        "account_sid": "acc-123",
        "from": "+911234567890",
        "to": "+919876543210",
        "custom_parameters": {
          "queuename": "premium",
          "product": "radio"
        },
        "media_format": {
          "encoding": "slin",
          "sample_rate": "8000",
          "bit_rate": "128k"
        }
      }
    }
    ```

    | **<u>Field</u>**      | **<u>Description</u>**                                                                                   |
    | :-------------------- | :------------------------------------------------------------------------------------------------------- |
    | **event**             | First packet number in the stream                                                                        |
    | **sequence_number**   | Unique stream ID                                                                                         |
    | **stream_sid**        | Call identifier                                                                                          |
    | **call_sid**          | Your platform’s account ID                                                                               |
    | **account_sid**       | Call participant numbers                                                                                 |
    | **from, to**          | Call participant numbers                                                                                 |
    | **custom_parameters** | Any custom fields passed via WebSocket query params                                                      |
    | **media_format**      | Always send<br />{       "encoding": "slin",       "sample_rate": "8000",       "bit_rate": "128k"     } |
  </Accordion>
  <Accordion title="media">
    <Info>
      Core message that carries base64-encoded audio data.
    </Info>
    ```json
    
    {
      "event": "media",
      "sequence_number": 3,
      "stream_sid": "stream-xyz",
      "media": {
        "chunk": 2,
        "timestamp": "10",
        "payload": "<base64-audio>"
      }
    }
    
    ```

    | **<u>Field</u>** | **<u>Description</u>**                                               |
    | :--------------- | :------------------------------------------------------------------- |
    | **chunk**        | Sequence number of the chunk                                         |
    | **timestamp**    | Time offset in milliseconds from stream start                        |
    | **payload**      | Audio payload (Base64-encoded PCM: 16-bit, 8kHz mono, little-endian) |
  </Accordion>
  <Accordion title="stop">
    <Info>
      Sent when the call ends or the stream is terminated.
    </Info>
    ```json
    {
      "event": "stop",
      "sequence_number": 10,
      "stream_sid": "stream-xyz",
      "stop": {
        "call_sid": "call-abc",
        "account_sid": "acc-123",
        "reason": "callended"
      }
    }
    
    ```

    | **<u>Field</u>** | **<u>Description</u>** | |
    | :--------------- | :--------------------- | :-- |
    | **reason**       | stopped or callended   | |
    |                  |                        | |
  </Accordion>
  <Accordion title="mark">
    <Info>
      Used to track media playback in bidirectional streams
    </Info>

    ```json
    {
      "event": "mark",
      "sequence_number": 15,
      "stream_sid": "stream-xyz",
      "mark": {
        "name": "audio_response_boundary"
      }
    }
    
    ```

    **How It Works**: You can send a mark message after sending media. Once the platform processes and plays back your audio, it will echo back a mark with the same name.
  </Accordion>
</AccordionGroup>

**To Formi**

<AccordionGroup>
  <Accordion title="clear" icon="sparkles">
    <Info>
      Clears any unplayed audio messages previously sent in media. Useful for interrupting long responses.
    </Info>
    ```json
    {
      "event": "clear",
      "stream_sid": "stream-xyz"
    }
    ```

    **Best Practice**:

    - Send media in short, discrete chunks (≤1s)
    - If media already began playback, only future chunks will be cleared
  </Accordion>
</AccordionGroup>


<Note>
  ### **Audio Format Guidelines**

  - **Codec: **16-bit PCM, 8kHz, mono, little-endian (Base64)
  - **Recommended chunk size:** 320 bytes per 100ms
  - **Max payload: **100KB

  Your telephony system must support and adhere to the above schema to reliably stream audio to and from Formi.
</Note>

## **Final Notes**

- Always call the Create Session API before the call stream starts.
- Keep session_id and interaction_id safe and link them with your call.
- Formi supports additional analytics, transcriptions, and AI decisioning layered on top of the stream.

<Warning>
  Use secure wss:// URLs and validate endpoints before opening connections.
</Warning>